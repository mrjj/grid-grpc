#!/usr/bin/env node
/**
 * @fileOverview: make GRPC client js file
 * inspired by Danby by ericbets
 * https://github.com/ericbets/danby
 */
const path = require('path')
const fs = require('fs')
const protobuf = require('protobufjs')
const Mustache = require('mustache')
const Yargs = require('yargs')
const logger = require('./logger')({name: 'grpc-cli'})

const {DEFAULT_CLI_CONFIG, DEFAULT_ENDPOINT_CONF} = require('./constants')

/**
 * Works like mkdir -p
 * @param pathToCreate
 * @return {string}
 */
const makePath = (pathToCreate) => pathToCreate.split(path.sep).reduce(
  (currentPath, folder) => {
    currentPath += folder + path.sep
    if (!fs.existsSync(currentPath)) {
      fs.mkdirSync(currentPath)
    }
    return currentPath
  },
  ''
)
const TEMPLATE = `/**
 * @fileoverview: GRPC Client file auto-generated by gen-web-client.ks
 */

/**
 * Third party
 */
{{library}}

/**
 * Generated code
 */
const protobuf = require('protobufjs');
const getClient = (options) => {
  const { wsSchema, grpcMountUrlPath } = {
    wsSchema: '{{wsSchema}}', 
    grpcMountUrlPath: '{{grpcMountUrlPath}}',
    ...(options || {})
  };
  const root = protobuf.Root.fromJSON({{protoJSON}});
  return {
{{services}}  };
};

module.exports = getClient;
`
const SERVICE_TEMPLATE = `    {{serviceName}}: {
{{methods}}    }
`

const METHOD_TEMPLATE = `      {{methodName}}: (data) => new Promise(function(resolve, reject) {
        const ws = new WebSocket(\`\${wsSchema\}://\${window.location.host\}\${grpcMountUrlPath}\`);
        ws.onopen = () => ws.send(JSON.stringify({ 
          service: '{{serviceName}}',
          method: '{{methodName}}',
          payload: data,
          metadata: {{metadata}},
        }));
        ws.onmessage = (evt) => resolve(JSON.parse(evt.data));
        ws.onerror = (e) => { logger.error(e); return reject(e); };
      }),
`
const searchService = (el = {}, services = {}) => {
  if (el && el.nested && el.nested.field) {
    const f = el.nested.field
    for (let field in f) {
      if (field !== 'parent') {
        if (f.hasOwnProperty(field)) {
          if (f[field] instanceof protobuf.Service) {
            services[field] = f[field]
          } else {
            services = searchService(f[field], services)
          }
        }
      }
    }
  }
  return services
}

const generateClientScript = async (protoPath, protobufJsLibDistPath, wsSchema = DEFAULT_ENDPOINT_CONF.wsSchema) => {
  Mustache.escape = (v) => v
  const root = await protobuf.load(protoPath)
  const servicesDict = searchService(root)
  let servicesStr = ''
  for (let serviceName in servicesDict) {
    if (serviceName && servicesDict.hasOwnProperty(serviceName)) {
      const svc = root.lookupService(serviceName)
      const methods = svc['methods']
      let methodsStr = ''
      for (let methodName in methods) {
        if (methods.hasOwnProperty(methodName)) {
          const method = methods[methodName]
          const view = {
            methodName,
            serviceName,
            metadata: JSON.stringify({}),
            requestType: method['requestType'],
            responseType: method['responseType'],
            wsSchema,
          }
          methodsStr += Mustache.render(METHOD_TEMPLATE, view)
        }
      }
      servicesStr += Mustache.render(SERVICE_TEMPLATE, {
        serviceName: serviceName,
        methods: methodsStr,
      })
    }
  }
  return Mustache.render(TEMPLATE, {
    services: servicesStr,
    wsSchema: DEFAULT_ENDPOINT_CONF.wsSchema,
    grpcMountUrlPath: DEFAULT_ENDPOINT_CONF.grpcMountUrlPath,
    protoJSON: JSON.stringify(root.toJSON(), null, 2).split('\n').join('\n  '),
    library: fs.readFileSync(protobufJsLibDistPath)
  })
}

/**
 * Add file extension before last one
 *
 * @example
 * addExt('./server.js.log', 'old')
 * > './server.js.old.log'
 *
 * @param p {string} - path
 * @param prefix {string} - new prefix extension
 * @return {string}
 */
const addPrefixExt = (p, prefix = 'old') => {
  const dn = path.dirname(p)
  const fn = path.basename(p)
  const pathParts = fn.split('.')
  const newFn = [
    ...pathParts.slice(0, pathParts.length - 1),
    prefix,
    pathParts[pathParts.length - 1],
  ].join('.')
  return path.join(dn, newFn)
}

const argv = Yargs
  .usage('$0 <cmd> [args]')
  .command(
    'gen [inputPath] [outputPath] [protobufJsLibDistPath]',
    'generate web client for GRPC based on .proto file',
    (yargs) => {
      yargs
        .positional('inputPath', {
          type: 'string',
          default: DEFAULT_CLI_CONFIG.inputProtoFilePath,
          describe: 'root `.proto` file with `service` declarations'
        })
        .positional('outputPath', {
          type: 'string',
          default: DEFAULT_CLI_CONFIG.outputJsFilePath,
          describe: 'grpc .js client output path'
        })
        .positional('protobufJsLibDistPath', {
          type: 'string',
          default: DEFAULT_CLI_CONFIG.protobufJsLibDistPath,
          describe: 'protobuf.min.js path'
        })

    },
    async ({inputPath, outputPath, protobufJsLibDistPath}) => {
      const fullInputPath = path.join(process.cwd(), inputPath)
      const fullOutputPath = path.join(process.cwd(), outputPath)
      const fullProtobufJsLibDistPath = path.join(process.cwd(), protobufJsLibDistPath)
      logger.info(`Making JS client: ${fullInputPath} -> ${fullOutputPath}`)
      makePath(path.dirname(fullOutputPath))

      /* Run */
      try {
        logger.info(`Building using protobufjs library file: ${fullProtobufJsLibDistPath}`)
        const apiScript = await generateClientScript(fullInputPath, fullProtobufJsLibDistPath)
        if (fs.existsSync(fullOutputPath)) {
          const prevPath = addPrefixExt(fullOutputPath, 'old')
          if (DEFAULT_CLI_CONFIG.keepOldBuilds) {
            logger.info(`Preserving existing file: ${fullOutputPath} -> ${prevPath} (to disable this set "DEFAULT_CLI_CONFIG.keepOldBuilds=false")`)
            if (fs.existsSync(prevPath)) {
              logger.info(`Deleting existing old build file: ${prevPath} (to disable this set "DEFAULT_CLI_CONFIG.keepOldBuilds=false")`)
              fs.unlinkSync(prevPath)
            }
            fs.renameSync(fullOutputPath, prevPath)
          } else {
            if (fs.existsSync(fullOutputPath)) {
              logger.info(`Deleting existing file: ${fullOutputPath}`)
              fs.unlinkSync(fullOutputPath)
            }
          }
        }
        fs.writeFileSync(fullOutputPath, apiScript)
      } catch (e) {
        logger.error(e)
        logger.error(`ERROR:\n${e.toString()}`)
      }
      logger.info(`Done! Result saved to:\n${fullOutputPath}`)
    }
  ).argv

module.exports = generateClientScript
