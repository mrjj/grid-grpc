#!/usr/bin/env node
/**
 * @fileOverview: make GRPC client js file
 * inspired by Danby by ericbets
 * https://github.com/ericbets/danby
 */
const path = require('path');
const fs = require('fs');
const protobuf = require('protobufjs');
const Mustache = require('mustache');
const Yargs = require('yargs');
const logger = require('./logger')({ name: 'grpc-cli' });

const { DEFAULT_CLI_CONFIG, DEFAULT_ENDPOINT_CONF } = require('./constants');

/**
 * Works like mkdir -p
 * @param pathToCreate
 * @return {string}
 */
const makePath = (pathToCreate) => pathToCreate.split(path.sep).reduce(
  (currentPath, folder) => {
    currentPath += folder + path.sep;
    if (!fs.existsSync(currentPath)) {
      fs.mkdirSync(currentPath);
    }
    return currentPath;
  },
  ''
);
const TEMPLATE = `/**
 * @fileoverview: GRPC Client file auto-generated by gen-web-client.ks
 */

/**
 * Third party
 */
{{library}}

/**
 * Generated code
 */
const protobuf = require('protobufjs');
const getClient = (options) => {
  const { wsSchema, grpcMountUrlPath } = {
    wsSchema: '{{wsSchema}}', 
    grpcMountUrlPath: '{{grpcMountUrlPath}}',
    ...(options || {})
  };
  const root = protobuf.Root.fromJSON({{protoJSON}});
  return {
{{services}}  };
};

module.exports = getClient;
`;
const SERVICE_TEMPLATE = `    {{serviceName}}: {
{{methods}}    }
`;

const METHOD_TEMPLATE = `      {{methodName}}: (data) => new Promise(function(resolve, reject) {
        const ws = new WebSocket(\`\${wsSchema\}://\${window.location.host\}\${grpcMountUrlPath}\`);
        ws.onopen = () => ws.send(JSON.stringify({ 
          service: '{{serviceName}}',
          method: '{{methodName}}',
          payload: data,
          metadata: {{metadata}},
        }));
        ws.onmessage = (evt) => resolve(JSON.parse(evt.data));
        ws.onerror = (e) => { logger.error(e); return reject(e); };
      }),
`;
const searchService = (el = {}, services = {}) => {
  if (el && el.nested && el.nested.field) {
    const f = el.nested.field;
    for (let field in f) {
      if (field !== 'parent') {
        if (f.hasOwnProperty(field)) {
          if (f[field] instanceof protobuf.Service) {
            services[field] = f[field];
          } else {
            services = searchService(f[field], services);
          }
        }
      }
    }
  }
  return services;
};

const generateClientScript = async (protoPath, wsSchema = DEFAULT_ENDPOINT_CONF.wsSchema) => {
  Mustache.escape = (v) => v;
  const root = await protobuf.load(protoPath);
  const servicesDict = searchService(root);
  let servicesStr = '';
  for (let serviceName in servicesDict) {
    if (serviceName && servicesDict.hasOwnProperty(serviceName)) {
      const svc = root.lookupService(serviceName);
      const methods = svc['methods'];
      let methodsStr = '';
      for (let methodName in methods) {
        if (methods.hasOwnProperty(methodName)) {
          const method = methods[methodName];
          const view = {
            methodName,
            serviceName,
            metadata: JSON.stringify({}),
            requestType: method['requestType'],
            responseType: method['responseType'],
            wsSchema,
          };
          methodsStr += Mustache.render(METHOD_TEMPLATE, view);
        }
      }
      servicesStr += Mustache.render(SERVICE_TEMPLATE, {
        serviceName: serviceName,
        methods: methodsStr,
      });
    }
  }
  return Mustache.render(TEMPLATE, {
    services: servicesStr,
    wsSchema: DEFAULT_ENDPOINT_CONF.wsSchema,
    grpcMountUrlPath: DEFAULT_ENDPOINT_CONF.grpcMountUrlPath,
    protoJSON: JSON.stringify(root.toJSON(), null, 2).split('\n').join('\n  '),
    library: fs.readFileSync(DEFAULT_CLI_CONFIG.protobufJsLibDistPath)
  });
};

/**
 * Add file extension before last one
 *
 * @example
 * addExt('./server.js.log', 'old')
 * > './server.js.old.log'
 *
 * @param p {string} - path
 * @param prefix {string} - new prefix extension
 * @return {string}
 */
const addPrefixExt = (p, prefix = 'old') => {
  const dn = path.dirname(p);
  const fn = path.basename(p);
  const pathParts = fn.split('.');
  const newFn = [
    ...pathParts.slice(0, pathParts.length - 1),
    prefix,
    pathParts[pathParts.length - 1],
  ].join('.');
  return path.join(dn, newFn);
};

const argv = Yargs
  .usage('$0 <cmd> [args]')
  .command(
    'gen [protoPath] [outputPath]',
    'generate web client for GRPC based on .proto file',
    (yargs) => {
      yargs
        .positional('protoPath', {
          type: 'string',
          default: DEFAULT_CLI_CONFIG.inputProtoFilePath,
          describe: 'root `.proto` file with `service` declarations'
        })
        .positional('outputPath', {
          type: 'string',
          default: DEFAULT_CLI_CONFIG.outputJsFilePath,
          describe: 'grpc .js client output path'
        })
      ;
    },
    async ({ protoPath, outputPath }) => {
      logger.info(`Making JS client: ${DEFAULT_CLI_CONFIG.inputProtoFilePath} -> ${DEFAULT_CLI_CONFIG.outputJsFilePath}`);
      makePath(path.dirname(outputPath));

      /* Run */
      try {
        const apiScript = await generateClientScript(protoPath);
        if (fs.existsSync(outputPath)) {
          const prevPath = addPrefixExt(outputPath, 'old');
          if (DEFAULT_CLI_CONFIG.keepOldBuilds) {
            logger.info(`Preserving existing file: ${outputPath} -> ${prevPath} (to disable this set "DEFAULT_CLI_CONFIG.keepOldBuilds=false")`);
            if (fs.existsSync(prevPath)) {
              logger.info(`Deleting existing old build file: ${prevPath} (to disable this set "DEFAULT_CLI_CONFIG.keepOldBuilds=false")`);
              fs.unlinkSync(prevPath);
            }
            fs.renameSync(outputPath, prevPath);
          } else {
            if (fs.existsSync(outputPath)) {
              logger.info(`Deleting existing file: ${outputPath}`);
              fs.unlinkSync(outputPath);
            }
          }
        }
        fs.writeFileSync(outputPath, apiScript);
      } catch (e) {
        logger.error(e);
        logger.error(`ERROR:\n${e.toString()}`);
      }
      logger.info(`Done! Result saved to:\n${DEFAULT_CLI_CONFIG.outputJsFilePath}`);
    }
  ).argv;


module.exports = generateClientScript;
